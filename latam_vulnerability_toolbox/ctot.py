
import pandas as pd
import numpy as np
import json
import os

class MonthlyWP1921_CTOT_Calculator:
    """
    Calculadora CTOT mensual basada en metodología WP/1921 Gruss y Kebhaj.
    Esta clase se enfoca únicamente en los cálculos.
    """
    
    def __init__(self, config_path='config'):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        mapping_path = os.path.join(base_dir, config_path, 'commodity_mapping.json')
        
        try:
            with open(mapping_path, 'r') as f:
                self.commodity_mapping = json.load(f)
        except FileNotFoundError:
            print(f"Error: No se pudo encontrar el fichero de mapeo de commodities en {mapping_path}")
            self.commodity_mapping = {}

    def get_commodity_groups(self, config_path='config'):
        """Carga los grupos de commodities desde un fichero de configuración."""
        base_dir = os.path.dirname(os.path.abspath(__file__))
        groups_path = os.path.join(base_dir, config_path, 'commodity_groups.json')
        
        try:
            with open(groups_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"Error: No se pudo encontrar el fichero de grupos de commodities en {groups_path}")
            return {}

    def load_imf_prices(self, file_path, cpi_deflator=None):
        df = pd.read_excel(file_path, sheet_name="External", skiprows=[1,2,3])
        df = df.set_index('Commodity')
        df.index = pd.to_datetime(df.index, format='%YM%m')
        df = df.loc[:, ~df.columns.str.contains('^Unnamed')]
        
        if cpi_deflator is not None:
            cpi_2016_avg = cpi_deflator.loc[cpi_deflator.index.year == 2016].mean()
            cpi_normalized = (cpi_deflator / cpi_2016_avg) * 100
            common_dates = df.index.intersection(cpi_normalized.index)
            df_filtered = df.loc[common_dates]
            cpi_filtered = cpi_normalized.loc[common_dates]
            for column in df_filtered.columns:
                df_filtered[column] = df_filtered[column] / cpi_filtered
            return df_filtered
        return df

    def map_trade_to_commodities(self, trade_df):
        trade_df = trade_df.copy()
        trade_df['cmdCode'] = trade_df['cmdCode'].astype(str).str.zfill(6)
        trade_df['IMF_Code'] = None
        
        mapped_count = 0
        for imf_code, hs_codes in self.commodity_mapping.items():
            hs_codes_6digit = [code.zfill(6) for code in hs_codes]
            mask = trade_df['cmdCode'].isin(hs_codes_6digit)
            trade_df.loc[mask, 'IMF_Code'] = imf_code
            mapped_count += mask.sum()
        
        print(f"Mapeo exitoso: {mapped_count}/{len(trade_df)} registros ({mapped_count/len(trade_df)*100:.1f}%)")
        return trade_df[trade_df['IMF_Code'].notna()].copy()

    def calculate_annual_weights(self, mapped_trade_df, country_code, gdp_dict):
        country_trade = mapped_trade_df[mapped_trade_df['reporterCode'] == int(country_code)].copy()
        
        if len(country_trade) == 0:
            return pd.DataFrame()
        
        annual_agg = country_trade.groupby(['year', 'IMF_Code', 'flowDesc'])['primaryValue'].sum().reset_index()
        trade_pivot = annual_agg.pivot_table(index=['year', 'IMF_Code'], columns='flowDesc', values='primaryValue', fill_value=0).reset_index()
        
        trade_pivot['exports'] = trade_pivot.get('Export', 0)
        trade_pivot['imports'] = trade_pivot.get('Import', 0)
        trade_pivot['net_exports'] = trade_pivot['exports'] - trade_pivot['imports']
        
        weights_list = []
        for _, row in trade_pivot.iterrows():
            year = row['year']
            if year in gdp_dict:
                weight = row['net_exports'] / (gdp_dict[year] * 1_000_000_000)
                weights_list.append({
                    'year': year, 'IMF_Code': row['IMF_Code'], 'weight': weight,
                    'net_exports': row['net_exports'], 'exports': row['exports'], 'imports': row['imports']
                })
        
        return pd.DataFrame(weights_list)

    def calculate_time_varying_weights(self, annual_weights_df):
        tv_weights = []
        min_year = annual_weights_df['year'].min()
        for year in sorted(annual_weights_df['year'].unique()):
            if year >= min_year + 3:
                lag_years = [year - 3, year - 2, year - 1]
                for commodity in annual_weights_df['IMF_Code'].unique():
                    historical = annual_weights_df[(annual_weights_df['IMF_Code'] == commodity) & (annual_weights_df['year'].isin(lag_years))]['weight']
                    if not historical.empty:
                        avg_weight = historical.mean()
                        tv_weights.append({'year': year, 'IMF_Code': commodity, 'weight_tv': avg_weight})
        return pd.DataFrame(tv_weights)

    def interpolate_weights_to_monthly(self, tv_weights_df, start_date=None, end_date=None):
        if start_date is None:
            start_date = f"{tv_weights_df['year'].min()}-01-01"
        if end_date is None:
            end_date = "2025-12-31"
        
        monthly_dates = pd.date_range(start=start_date, end=end_date, freq='MS')
        monthly_weights = []
        last_available_weights = None
        
        for date in monthly_dates:
            year = date.year
            year_weights = tv_weights_df[tv_weights_df['year'] == year]
            
            if year_weights.empty and last_available_weights is not None:
                year_weights = last_available_weights
            elif not year_weights.empty:
                last_available_weights = year_weights
            
            for _, row in year_weights.iterrows():
                monthly_weights.append({'date': date, 'IMF_Code': row['IMF_Code'], 'weight_tv': row['weight_tv']})
        
        return pd.DataFrame(monthly_weights)

    def calculate_monthly_ctot(self, prices_df, monthly_weights_df, start_date=None):
        if start_date is None:
            start_date = monthly_weights_df['date'].min()
        else:
            start_date = pd.to_datetime(start_date)
        
        prices_filtered = prices_df[prices_df.index >= start_date].copy()
        log_prices = np.log(prices_filtered)
        price_changes = log_prices.diff()
        
        results = []
        for date in price_changes.index:
            if price_changes.loc[date].isnull().all():
                continue
            
            month_weights = monthly_weights_df[monthly_weights_df['date'] == date]
            if month_weights.empty:
                continue

            merged = pd.merge(price_changes.loc[date].rename('price_change'), month_weights, left_index=True, right_on='IMF_Code')
            merged.dropna(subset=['price_change', 'weight_tv'], inplace=True)
            
            if not merged.empty:
                ctot_change = (merged['price_change'] * merged['weight_tv']).sum()
                results.append({
                    'date': date, 'ctot_log_change': ctot_change,
                    'ctot_pct_gdp': ctot_change * 100, 'n_commodities': len(merged)
                })
        
        results_df = pd.DataFrame(results)
        if not results_df.empty:
            results_df['ctot_level'] = 100 * np.exp(results_df['ctot_log_change'].cumsum())
        
        return results_df

    def calculate_group_contributions(self, prices_df, monthly_weights_df, monthly_results_df):
        groups = self.get_commodity_groups()
        log_prices = np.log(prices_df)
        price_changes = log_prices.diff()
        
        group_contributions = []
        for _, result_row in monthly_results_df.iterrows():
            date = result_row['date']
            if date not in price_changes.index:
                continue
            
            month_weights = monthly_weights_df[monthly_weights_df['date'] == date]
            if month_weights.empty:
                continue
            
            row_data = {'date': date, 'total_ctot_change': result_row['ctot_pct_gdp']}
            for group_name, group_info in groups.items():
                group_commodities = group_info['commodities']
                merged = pd.merge(price_changes.loc[date].rename('price_change'), month_weights, left_index=True, right_on='IMF_Code')
                merged = merged[merged['IMF_Code'].isin(group_commodities)]
                merged.dropna(subset=['price_change', 'weight_tv'], inplace=True)
                
                if not merged.empty:
                    row_data[f'{group_name}_contribution'] = (merged['price_change'] * merged['weight_tv']).sum() * 100
                else:
                    row_data[f'{group_name}_contribution'] = 0
            
            group_contributions.append(row_data)
        
        return pd.DataFrame(group_contributions)
